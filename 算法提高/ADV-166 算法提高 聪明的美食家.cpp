算法提高 聪明的美食家
问题描述
　　如果有人认为吃东西只需要嘴巴，那就错了。
　　都知道舌头有这么一个特性，“由简入奢易，由奢如简难”（据好事者考究，此规律也适合许多其他情况）。具体而言，如果是甜食，当你吃的食物不如前面刚吃过的东西甜，就很不爽了。
　　大宝是一个聪明的美食家，当然深谙此道。一次他来到某小吃一条街，准备从街的一头吃到另一头。为了吃得爽，他大费周章，得到了各种食物的“美味度”。他拒绝不爽的经历，不走回头路而且还要爽歪歪（爽的次数尽量多）。
输入格式
　　两行数据。
　　第一行Z为一个整数n，表示小吃街上小吃的数量
　　第二行为n个整数，分别表示n种食物的“美味度”
输出格式
　　一个整数，表示吃得爽的次数
样例输入
10
3 18 7 14 10 12 23 41 16 24
样例输出
6
数据规模和约定
　　美味度为0到100的整数
　　n<1000
分析：求最长不降子序列~用动态规划解决~建立一个与序列等长的数组a~a[i]表示当前i处能够构成的最长不降子序列的长度~
所以说当前a[i]的值为前面所有数字比i处数字小的长度的最大值+1~
#include <iostream>
using namespace std;
#define max(a, b) (a) > (b) ? (a) : (b)
int main() {
    int n;
    cin >> n;
    int *a = new int [n];
    int *b = new int [n];
    for(int i = 0; i < n; i++)
        cin >> a[i];
    b[0] = 1;
    int ans = 1;
    for(int i = 0; i < n; i++) {
        int maxvalue = 0;
        for(int j = i-1; j >= 0; j--) {
            if(a[i] >= a[j])
                maxvalue = max(maxvalue, b[j]);
        }
        b[i] = maxvalue + 1;
        ans = max(ans, b[i]);
    }
    cout << ans;
    return 0;
}