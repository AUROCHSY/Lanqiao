算法训练 纪念品分组
问题描述
　　元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得的纪念品价值 相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时 间内发完所有纪念品，乐乐希望分组的数目最少。
　　你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。
输入格式
　　输入包含n+2行：
　　第1行包括一个整数w，为每组纪念品价格之和的上限。
　　第2行为一个整数n，表示购来的纪念品的总件数。
　　第3~n+2行每行包含一个正整数pi (5 <= pi <= w)，表示所对应纪念品的价格。
输出格式
　　输出仅一行，包含一个整数，即最少的分组数目。
样例输入
100
9
90
20
20
30
50
60
70
80
90
样例输出
6
数据规模和约定
　　50%的数据满足：1 <= n <= 15
　　100%的数据满足：1 <= n <= 30000, 80 <= w <= 200

分析：排序+贪心。先从小到大排序，i、j指针分别从左到右、从右到左遍历。
如果a[i]+a[j] <= w，那么把这两个物品都放入同一组，并且同时移动指针；
否则，只能把j所指向的物品放入单独的一个组，移动j指针...直到i j把所有物品都遍历完~
分析下贪心算法的可行性：如果j物品和i物品加起来超过了w，因为j物品比j+1处的物品价值小，那么如果i不能满足加起来的条件，而i-1能满足该条件，是否会影响贪心算法的结果呢？
如果让j和i-1去组合，对于j+1，因为价值比j更大，所以就更放不进i了，所以即使交换组合方式还是不影响构成的组数的~
至于为什么是i <= j，当i<j的时候，假设ij已经相邻，那么此时还能再比较一次i+j能否满足构成一组的条件，如果满足就会把它们放到一组，之后ij指针同时移动后i>j不能够满足进入循环的条件了；如果不满足把它们放入一组，那么j放入一组后j移动指针，使i==j，继续进入循环；
当i=j的时候，因为这个单独的物品已经没有可以组合的物品剩余了，所以此时还要进入循环进行一次cnt++的计数操作~//这就是while(i <= j)的解释

#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
int main() {
	int w, n;
	scanf("%d %d", &w, &n);
	int *a = new int[n];
	for(int i = 0; i < n; i++)
		scanf("%d", &a[i]);
	sort(a, a+n);
	int i = 0, j = n-1, cnt = 0;
	while(i <= j) {
		if(a[i] + a[j] <= w) {
			i++;
		}
		cnt++;
		j--;
	}
	cout << cnt;
	return 0;
}



